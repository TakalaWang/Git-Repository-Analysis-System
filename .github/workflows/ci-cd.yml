name: Build & Deploy (DockerHub + SSH + Firebase SA file)

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  build-and-deploy:
    runs-on: ubuntu-latest
    permissions:
      contents: read
      packages: read

    steps:
      - name: Checkout
        uses: actions/checkout@v4

      - name: Setup Node & PNPM
        uses: actions/setup-node@v4
        with:
          node-version: 20
          cache: "pnpm"
      - uses: pnpm/action-setup@v4
        with:
          version: 9

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      - name: Build app (Next.js standalone)
        run: pnpm build

      # 只把執行期需要的檔案打進 image，保持輕量
      - name: Prepare minimal docker context
        run: |
          mkdir -p docker_ctx/.next
          cp -r .next/standalone docker_ctx/.next/standalone
          cp -r .next/static docker_ctx/.next/static
          if [ -d public ]; then cp -r public docker_ctx/public; fi
          cp Dockerfile docker_ctx/Dockerfile

      - name: Login to Docker Hub
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
          DOCKERHUB_TOKEN: ${{ secrets.DOCKERHUB_TOKEN }}
        run: |
          echo "${DOCKERHUB_TOKEN}" | docker login -u "${DOCKERHUB_USERNAME}" --password-stdin

      - name: Build & push image
        env:
          DOCKERHUB_USERNAME: ${{ secrets.DOCKERHUB_USERNAME }}
        run: |
          IMAGE="${DOCKERHUB_USERNAME}/git-repo-analysis"
          GIT_SHA="${{ github.sha }}"
          docker build -t ${IMAGE}:latest -t ${IMAGE}:${GIT_SHA} docker_ctx
          docker push ${IMAGE}:latest
          docker push ${IMAGE}:${GIT_SHA}

      # 由 Secrets 動態產生 .env（不進 repo），並指定 SA 檔路徑
      - name: Generate .env from secrets
        run: |
          mkdir -p env_out
          {
            echo "NEXT_PUBLIC_FIREBASE_API_KEY=${{ secrets.NEXT_PUBLIC_FIREBASE_API_KEY }}"
            echo "NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN=${{ secrets.NEXT_PUBLIC_FIREBASE_AUTH_DOMAIN }}"
            echo "NEXT_PUBLIC_FIREBASE_PROJECT_ID=${{ secrets.NEXT_PUBLIC_FIREBASE_PROJECT_ID }}"
            echo "NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET=${{ secrets.NEXT_PUBLIC_FIREBASE_STORAGE_BUCKET }}"
            echo "NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID=${{ secrets.NEXT_PUBLIC_FIREBASE_MESSAGING_SENDER_ID }}"
            echo "NEXT_PUBLIC_FIREBASE_APP_ID=${{ secrets.NEXT_PUBLIC_FIREBASE_APP_ID }}"
            echo "GEMINI_API_KEY=${{ secrets.GEMINI_API_KEY }}"
            # 指向容器內掛載的位置（與 docker run 的 -v 對齊）
            echo "GOOGLE_APPLICATION_CREDENTIALS=./service-account-file.json"
            # 容器內部預設埠；對外埠用 DEPLOY_PORT 控制
            echo "PORT=3000"
          } > env_out/.env

      # 從 Secrets 寫出 Firebase Service Account 實體檔
      - name: Write Firebase service account file
        run: |
          echo '${{ secrets.FIREBASE_SERVICE_ACCOUNT }}' > env_out/service-account-file.json

      # 上傳 .env 與 SA 檔到 VM 的 shared 目錄
      - name: Upload env and service account to VM
        uses: appleboy/scp-action@v0.1.4
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          source: "env_out/.env,env_out/service-account-file.json"
          target: "${{ secrets.VM_APP_DIR || '/opt/git-repo-analysis' }}/shared"
          overwrite: true

      # SSH 進 VM：安裝 docker（若無）、pull 最新映像、以 volume 掛載 SA 檔啟動
      - name: Deploy on VM (install docker if needed, pull & run)
        uses: appleboy/ssh-action@v1.0.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          script_stop: true
          script: |
            set -e

            APP_DIR="${{ secrets.VM_APP_DIR || '/opt/git-repo-analysis' }}"
            IMAGE="${{ secrets.DOCKERHUB_USERNAME }}/git-repo-analysis:latest"
            CONTAINER="git-repo-analysis"
            EXTERNAL_PORT="${{ secrets.DEPLOY_PORT || '3000' }}"

            # 準備目錄
            sudo mkdir -p "$APP_DIR/shared"
            sudo chown -R $USER:$USER "$APP_DIR"

            # 安裝 docker（若缺）
            if ! command -v docker >/dev/null 2>&1; then
              curl -fsSL https://get.docker.com | sh
              sudo usermod -aG docker $USER || true
            fi

            # 如 Docker Hub 私有倉庫，可在 VM 登入（選用）
            # echo "${{ secrets.DOCKERHUB_TOKEN }}" | docker login -u "${{ secrets.DOCKERHUB_USERNAME }}" --password-stdin

            # 拉最新映像
            docker pull "$IMAGE"

            # 停舊起新
            if [ "$(docker ps -q -f name=${CONTAINER})" ]; then
              docker stop ${CONTAINER} || true
              docker rm ${CONTAINER} || true
            elif [ "$(docker ps -aq -f name=${CONTAINER})" ]; then
              docker rm ${CONTAINER} || true
            fi

            # 啟動容器：讀 VM 上的 .env，並掛載 SA JSON 檔到 /app
            docker run -d \
              --name ${CONTAINER} \
              --restart unless-stopped \
              --env-file "$APP_DIR/shared/.env" \
              -v "$APP_DIR/shared/service-account-file.json:/app/service-account-file.json:ro" \
              -p ${EXTERNAL_PORT}:3000 \
              "$IMAGE"

            # 清理 dangling images
            docker image prune -f || true
