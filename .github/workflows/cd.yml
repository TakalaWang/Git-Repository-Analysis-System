name: CD

on:
  push:
    branches: ["main"]
  workflow_dispatch:

jobs:
  deploy-to-vm:
    runs-on: ubuntu-latest

    steps:
      - name: Deploy & Build
        uses: appleboy/ssh-action@v1.2.3
        with:
          host: ${{ secrets.SSH_HOST }}
          username: ${{ secrets.SSH_USER }}
          key: ${{ secrets.SSH_KEY }}
          script: |
            set -euo pipefail

            # ===== Parameters (no secrets leave the VM) =====
            APP_DIR="${{ secrets.VM_APP_DIR }}"; APP_DIR="${APP_DIR:-$HOME/git-repo-analysis}"
            REPO_URL="https://github.com/${{ github.repository }}.git"
            PORT="${{ secrets.DEPLOY_PORT }}"; PORT="${PORT:-3000}"
            SERVICE_NAME="${SERVICE_NAME:-git-repo-analysis}"  # systemd unit name if you use one

            echo "APP_DIR=$APP_DIR  PORT=$PORT"

            # ===== Install/Upgrade to the latest Node using nvm, then enable latest pnpm via corepack =====
            # We install nvm to $HOME/.nvm (no sudo), then always switch to the latest Node ("node" channel).
            export NVM_DIR="$HOME/.nvm"
            if [ ! -s "$NVM_DIR/nvm.sh" ]; then
              echo "Installing nvm..."
              mkdir -p "$NVM_DIR"
              curl -fsSL https://raw.githubusercontent.com/nvm-sh/nvm/v0.39.7/install.sh | bash
            fi
            # shellcheck disable=SC1090
            . "$NVM_DIR/nvm.sh"

            echo "Installing latest Node (channel: node)..."
            nvm install --no-progress node
            nvm alias default node
            nvm use default

            # Enable corepack and activate the latest pnpm
            if command -v corepack >/dev/null 2>&1; then
              corepack enable || true
              corepack prepare pnpm@latest --activate || true
            fi

            # Ensure PNPM_HOME is in PATH (for pnpm launcher installed by corepack or installer)
            export PNPM_HOME="${PNPM_HOME:-$HOME/.local/share/pnpm}"
            export PATH="$PNPM_HOME:$PATH"

            # Fallback: if pnpm still not found, install via official script
            if ! command -v pnpm >/dev/null 2>&1; then
              echo "pnpm not found; installing via script..."
              curl -fsSL https://get.pnpm.io/install.sh | sh -
              export PATH="$PNPM_HOME:$PATH"
            fi

            echo "Node: $(node -v)"
            echo "pnpm: $(pnpm -v)"

            # ===== Fetch latest code =====
            mkdir -p "$APP_DIR"
            cd "$APP_DIR"
            if [ -d .git ]; then
              git remote set-url origin "$REPO_URL" || true
              git fetch --all --prune
              git reset --hard origin/main
            else
              git clone "$REPO_URL" .
              git checkout main || true
            fi

            # ===== Stop existing app (prefer systemd; fallback to pidfile/port kill) =====
            stop_port () {
              local port="$1"
              local pids
              # Use 'ss' + 'sed' (portable; no awk/lsof dependency)
              pids="$(ss -lptn "sport = :$port" 2>/dev/null | sed -n 's/.*pid=\([0-9][0-9]*\).*/\1/p' | sort -u || true)"
              if [ -n "$pids" ]; then
                echo "Killing processes on port $port: $pids"
                for p in $pids; do kill "$p" 2>/dev/null || true; done
                sleep 1
                for p in $pids; do kill -9 "$p" 2>/dev/null || true; done
              else
                echo "No process found on port $port"
              fi
            }

            if command -v systemctl >/dev/null 2>&1 && systemctl list-units --type=service | grep -q "$SERVICE_NAME"; then
              echo "Stopping systemd service: $SERVICE_NAME"
              sudo systemctl stop "$SERVICE_NAME" || true
            else
              echo "Stopping via pidfile/port..."
              if [ -f ".next.pid" ]; then
                OLD_PID="$(cat .next.pid || true)"
                if [ -n "${OLD_PID:-}" ] && kill -0 "$OLD_PID" 2>/dev/null; then
                  kill "$OLD_PID" || true
                  sleep 1
                  kill -9 "$OLD_PID" 2>/dev/null || true
                fi
                rm -f .next.pid
              fi
              stop_port "$PORT"
            fi

            # ===== Build on VM (env stays on VM) =====
            echo "Installing dependencies with pnpm..."
            pnpm install --frozen-lockfile

            echo "Building app..."
            export NEXT_TELEMETRY_DISABLED=1
            # Your app should read .env and FIREBASE_SERVICE_ACCOUNT_JSON_PATH from files already on the VM
            pnpm build

            # ===== Start app (systemd preferred; fallback to nohup) =====
            if command -v systemctl >/dev/null 2>&1 && systemctl list-units --type=service | grep -q "$SERVICE_NAME"; then
              echo "Starting via systemd: $SERVICE_NAME"
              sudo systemctl start "$SERVICE_NAME"
              sudo systemctl status "$SERVICE_NAME" --no-pager -l || true
            else
              echo "Starting via nohup on port $PORT..."
              export PORT="$PORT"
              nohup pnpm start -- -p "$PORT" > app.log 2>&1 &
              echo $! > .next.pid
              sleep 5
              if ps -p "$(cat .next.pid)" >/dev/null 2>&1; then
                echo "Started. PID=$(cat .next.pid)"
              else
                echo "Start failed. Last 80 lines:"
                tail -80 app.log || true
                exit 1
              fi
            fi

            echo "Deployment completed."
